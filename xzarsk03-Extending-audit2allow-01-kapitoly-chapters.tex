\chapter{Introduction}
TODO: motivation - longer

TODO: how I solved it, avoid first person

TODO: overview which chapter solves what

\chapter{Security-Enhanced Linux and audit2allow}
TODO: describe SELinux, describe audit2allow, use examples, what are the
problems of SELinux. Purpose of audit2allow, how is it used, how does it work,
internal structure of audit2allow.

\section{Discretionary Access Control}
Discretionary access control is defined by TCSES standard. System with DAC must
enable users to protect their data by controlling access to that data, e.g. by
setting permissions for other users or user groups.

In DAC, users make security decisions by specifying who can access their data.
The problem is that users can easily propagate information.

Linux implements discretionary access control. Every object has an owner that
controls access to that object. Permissions are set in three scopes: user,
group, and others. For each scope, permissions to read, write and execute can be
set.

\section{Mandatory Access Control}
Mandatory access control (MAC), defined by \emph{Trusted Computer System
Evaluation Criteria} (TCSEC) standard \cite{orangebook}, provides more
restrictions than DAC. In this type of access control, operating system can
prevent subjects to perform operations on objects. This is achieved by attaching
subjects and objects set of security attributes. When a subject (usually a
process) wants to perform an operation on an object (file, directory, socket,
etc.), operating system first examines these attributes. Security policy is then
used to determine whether this operation should be allowed or not. When using
MAC, users do not have the ability to override the security policy and, for
example, propagate sensitive information.

There are several implementations of MAC. Linux kernel currently contains
several security modules implemented using \emph{Linux Security Modules} (LSM)
framework \cite{lsmusage}. \emph{Security-Enhanced Linux} (SELinux), developed
by National Security Agency and Red Hat \cite{selinuxcontr}, is used in Red Hat
Enterprise Linux (RHEL), CentOS, Fedora and Android
\cite{selinuxguide,selinuxguidefedora,selinuxandroid}. \emph{AppArmor},
developed by SUSE, is used in SUSE Linux Enterprise, openSUSE and Ubuntu
\cite{apparmor,apparmorubuntu}. There are two other security modules,
\emph{Smack} and \emph{TOMOYO Linux}.

\section{Security-Enhanced Linux}
Security-Enhanced Linux (SELinux) is a Linux kernel security module that
provides mandatory access control mechanisms. (TODO)

\subsection{What problems does SELinux solve}
Without SELinux, operating system relies on traditinal access control methods
such as file permissions. Users can grant insecure file permissions to others or
gain access to files that they do not need. For example:
\begin{itemize}
    % TODO read permissions for everyone on file.. rephrase
    \item Users can reveal sensitive information by setting world readable
        permissions on files. For example, they can set read permission for
        everyone on ssh keys in \texttt{\textasciitilde/.ssh/} directory.
    \item Processes can change security properties: mail client can make user's
        mail readable by other users.
    \item Processes inherit user's rights. For example, every application, even
        though it may be compromised, is able to read all user's files.
\end{itemize}

With enabled SELinux, every action is denied by default. A security policy is
written which allows individual applications to perform actions required to
function. Applications do not need to be aware of SELinux. When an action is
denied, it is reported via ``access denied'' error code to the application
\cite{centoshowto}.

\subsection{How does SELinux enforce a security policy}
The high-level process of enforcing the policy:
\begin{enumerate}
    \item A \emph{subject} wants to perform an action upon an \emph{object}.
    \item An \emph{Object Manager} queries the \emph{Security Server} for a
    decision.
    \item \emph{Security Server} consults the \emph{Security Policy}
    and makes decision to allow or deny the action.
\end{enumerate}

% TODO
Figure 1: High-level process of policy enforcing

For example, when process \texttt{httpd} wants to open the
\texttt{/etc/httpd/conf/httpd.conf} file, the operation is allowed. It is
desirable to allow \texttt{httpd} access its configuration files, so the SELinux
policy contains rules that allow this operation. But if process \texttt{httpd}
would want to write to the \texttt{/etc/passwd} file, the operation would be
denied. Process \texttt{httpd} should not change the \texttt{/etc/passwd} file,
so the rules which would allow this operation are not present in policy.

There are 3 modes of operation. The default mode is \emph{enforcing}. In this
mode, everything which is not allowed by the policy is denied. When a process
tries to perform an action which is not allowed by the policy, it is logged. In
\emph{permissive} mode, SELinux is not enforcing the policy, it only logs
actions. In \emph{disabled} mode, SELinux is turned off.

\subsection{SELinux components}
% TODO
Figure 2: SELinux components

SELinux \emph{security server} is embedded in the kernel and it obtains the
security policy via userspace tools.

\emph{Object managers} resides mainly in kernel and make use of hooks provided
by Linux Security Module framework. There are object managers for kernel
services such as files, sockets, IPC etc. Userspace object managers are known as
``SELinux-aware'' applications and adds MAC support for X-Windows, D-bus
messaging, databases, etc.

SELinux \emph{security policy} is contained in \texttt{/etc/selinux} directory.
It consists of base policy and several policy modules. Base policy contains
information required by other modules. Policy modules usually supports one
particular service or application (e.g. policy module for Apache web server)
\cite[pp.~20--22]{tsn}.

Maintaining SELinux requires several userspace tools. The \texttt{checkmodule},
\texttt{checkpolicy}, \texttt{load\_policy} commands compile and load policy.
The \texttt{semanage} and \texttt{restorecon} command manages security labels of
various system resources \cite[p.~389]{tsn}.

\section{SELinux Policy Language}
Security decisions made by the security server in kernel are resolved using
SELinux policy. The policy is either monolithic (compiled from single source
file) or modular. Modular policy, which is used in Fedora and RHEL, consists of
mandatory base policy source file and loadable modules. In Fedora, almost every
module contains policy for one application or service, such as the
\texttt{apache} or \texttt{xserver} modules.

SELinux policy statements starts with a statement keyword usually followed by
several identifiers and semicolon at the end. Comments starts with a ``\#''.
Example of an allow rule:

\begin{lstlisting}
# This is an allow rule
allow httpd_t httpd_exec_t: file { ioctl read getattr lock map execute open };
\end{lstlisting}

SELinux assigns context to objects in the system. A \emph{SELinux context}
consists of user, role and type. In order to assign objects types, they must be
declared using the type statement.

\begin{lstlisting}
# declare type bin_t
type bin_t;
\end{lstlisting}

For assigning context to a file, the \texttt{file\_contexts} file (which is
compiled together with the policy source file) is used. For assigning contexts
to other objects, there are several policy statements, such as \texttt{portcon}
(for TCP/IP ports), \texttt{nodecon} (for IP addresses), or \texttt{netifcon}
(for network interfaces).

TODO processes, transitions

\section{Problems with SELinux}
TODO

\section{Linux Audit System}
The \emph{Linux Audit system} provides an auditing system for tracking
security-relevant system events. It is used to track file access, monitor system
calls, record commands run by user, record failed login attempts and others
\cite{secguide}. The Linux Audit system does not provide additional security by
itself, it can be only used to discover security violations.

The Linux Audit system consists of kernel and userspace part. Kernel filters
events and sends them to the \emph{audit daemon}. Audit daemon then writes the
received events to log file. There are several userspace tools used for
interacting with the audit system and for working with the log file.

\section{Audit and SELinux}
In Fedora and RHEL, SELinux uses the Linux Audit system to log security events.
When a process tries to perform operation without the permissions, an
\emph{Access Vector Cache} (AVC) denial message is logged using the audit daemon
\cite{selinuxguide}. This message can be then processed by tools such as
\texttt{setroubleshoot} or \texttt{audit2allow}.

Every AVC message contains information about \emph{source context} (the context
of the process), \emph{object class} (for example file), and \emph{target
context} (the context of the object). For example, when a process \texttt{httpd}
running in context \texttt{unconfined\_u:system\_r:httpd\_t:s0} is trying to
perform the \texttt{getattr} operation on file \texttt{/var/www/html/file1} with
context \texttt{system\_u:object\_r:samba\_share\_t:s0} and fails, the following
AVC message is generated:

\begin{lstlisting}
type=AVC msg=audit(1223024155.684:49): avc:  denied  { getattr }
for pid=2000 comm="httpd" path="/var/www/html/file1" dev=dm-0
ino=399185 scontext=unconfined_u:system_r:httpd_t:s0
tcontext=system_u:object_r:samba_share_t:s0 tclass=file
\end{lstlisting}

\section{The audit2allow Tool}
The \emph{audit2allow} is a userspace tool that scans the AVC messages and
generates SELinux policy snippets based on them.

\subsection{Purpose of audit2allow}
The audit2allow tool is designed to help administrators troubleshoot SELinux
denials.

TODO: basic mode - generating rules, admin can decide whether they could be
allowed, for development - devels can use permissive domain, run tests, collect
AVC, create basis for policy module, additional useful info - booleans,
interfaces, ...

\subsection{TODO: What It Does}
In default mode, it scans the AVC denial messages and generates policy rules
which allows the operations that were denied.

For example, when the \texttt{httpd} process tries to perform \texttt{getattr}
action on the \texttt{/var/www/html/file1} file, the following AVC message is
generated:
\begin{lstlisting}
type=AVC msg=audit(1223024155.684:49): avc:  denied  { getattr }
for pid=2000 comm="httpd" path="/var/www/html/file1" dev=dm-0
ino=399185 scontext=unconfined_u:system_r:httpd_t:s0
tcontext=system_u:object_r:samba_share_t:s0 tclass=file
\end{lstlisting}
The audit2allow would generate the following policy rule:
\begin{lstlisting}
allow httpd_t samba_share_t:file getattr;
\end{lstlisting}

The audit2allow is able to read AVC messages from stdin, dmesg, audit log, or
arbitrary file. There is \texttt{-{}-boot} option which loads only messages
generated since last boot and \texttt{-{}-lastreload} option which loads only
messages since last policy reload.

The audit2allow can output the policy rules directly to stdout or file, or
create a policy module which can be loaded directly into the policy.

% TODO make sure that booleans are explained earlier
The audit2allow is using currently loaded policy (or any other policy specified
in the \texttt{-{}-policy} option) to get more information about the denials.
For example, audit2allow suggests turning on a boolean that would allow the
denied operations.

When run with the \texttt{-{}-reference} option, audit2allow tries to match the
denials against defined interfaces. Example of audit2allow output without the
\texttt{-{}-reference} option:
\begin{lstlisting}
#============= httpd_t ==============
allow httpd_t samba_share_t:file getattr;
\end{lstlisting}
Example of audit2allow output with the \texttt{-{}-reference} option:
\begin{lstlisting}
require {
	type httpd_t;
}

#============= httpd_t ==============
samba_read_share_files(httpd_t)
\end{lstlisting}
The audit2allow found an interface which contained the same allow
rule. Interfaces creates more readable code but can contain more rules that are
necessary.

TODO: dontaudit rules

\subsection{TODO: How Does audit2allow Work}
The audit2allow first collects audit messages from various sources and then
filters out AVC messages and other useful messages. From every AVC message,
source context, target context, object class, and permissions are extracted and
converted into \emph{access vector sets}. Each access vector has unique source
context, target context, and object class combination. Permissions from multiple
AVC messages are merged into one access vector. Example of an access vector set:
% TODO: do it better
\begin{lstlisting}
{
    ("unconfined_u:system_r:httpd_t:s0",
     "system_u:object_r:samba_share_t:s0",
     "file"): [ "getattr", "open" ],
    ("unconfined_u:system_r:httpd_t:s0",
     "system_u:object_r:sssd_conf_t:s0",
     "file"): [ "getattr" ],
}
\end{lstlisting}

Each access vector is then converted into an allow rule. Example:
\begin{lstlisting}
allow httpd_t samba_share_t:file { getattr, open };
allow httpd_t sssd_conf_t:file getattr;
\end{lstlisting}

Various other information is stored during processing. The audit2allow prints
comments with helpful messages. TODO

\chapter{Analysis}
TODO

\section{Mislabeled Files}
When accessing files, SELinux relies on labels stored with those files to make a
security decision. SELinux labels can be viewed using the \texttt{ls -Z}
command:
\begin{lstlisting}
$ ls -Z
unconfined_u:object_r:user_home_t:s0    testdir
unconfined_u:object_r:user_home_t:s0    testfile
\end{lstlisting}
Labels are stored in extended attributes in the security namespace
\cite{xattrman}:
\begin{lstlisting}
$ getfattr -n security.selinux testfile
# file: testfile
security.selinux="unconfined_u:object_r:user_home_t:s0
\end{lstlisting}

There are rules in policy that specifies the default context of every file based
on its path and file type (regular file, directory, socket file, etc.). The
rules are written using regular expressions and can be found in the
\texttt{file\_contexts} file. Example:
\begin{lstlisting}
/run/.*         --  system_u:object_r:var_run_t:s0
/var/.*	        --  system_u:object_r:var_t:s0
/etc/.*	        --  system_u:object_r:etc_t:s0
/lib/.*	        --  system_u:object_r:lib_t:s0
/usr/.*\.cgi    --  system_u:object_r:httpd_sys_script_exec_t:s0
/root(/.*)?     --  system_u:object_r:admin_home_t:s0
/dev/[0-9].*    -c  system_u:object_r:usb_device_t:s0
/dev/.*tty[^/]* -c  system_u:object_r:tty_device_t:s0
\end{lstlisting}
The \texttt{-{}-} is means every file type, \texttt{-c} means character device.
When a new file is created, its context is looked up in default labeling rules
\cite[pp.~31-33]{tsn}.
For example, new file in the \texttt{/root} directory would obtain label
\texttt{system\_u:object\_r:admin\_home\_t:s0}.

TODO: audit2allow assumes correct labels, some rules does not make sense, there
is sometimes path field, but mostly only inode and file name.

\section{Extended Permissions}
TODO: new policy statements, extends classic allow rules, currently supported
only ioctl command, audit2allow does not generate them, audit2allow should parse
the ioctlcmd field and generate allowxperm rules, discussion about default
behaviour.

\section{TODO: Labeling Network Ports, Nodes and Interfaces}
TODO

\section{TODO: Checking Neverallow Rules}
TODO

\chapter{Implementation}
TODO

\section{Extended permissions}
TODO

\chapter{Functional Testing}
TODO: about tests, chosen coverage

\section{Unit Tests}

TODO: test\_access

TODO: test\_audit

TODO: test\_policygen

TODO: test\_refpolicy

\section{Integration Tests}

TODO

\chapter{Summary}
TODO
