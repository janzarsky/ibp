% Statuses:
% 0 - not started
% 1 - started, ideas collected
% 2 - less than half the length
% 3 - half the length
% 4 - full length, may need rephrasing
% 5 - done
% ==============================================================================
\chapter{Introduction}
% STATUS: 1
% TODO: improve
% motivation - longer
% how I solved it, avoid first person
% overview which chapter solves what

% establish your territory
%   state the general topic and give some background
Security-Enhanced Linux is a mandatory access control mechanism used in Linux
distributions. The audit2allow utility is used for analyzing security denials
and creating snippets of security policy.
%   provide a review of the literature related to the topic
%   define the terms and scope of the topic

% establish a niche
%   outline the current situation
%   evaluate the current situation (advantages/ disadvantages) and identify the gap
The audit2allow utility fails to provide effective and secure solution in
certain situations. It relies on objects having correct labels and it does not
recognize certain security policy statements.

% introduce the current research
%   identify the importance of the proposed research
Because of audit2allow, users often end up with policy rules that are too
permissive and thus unsecure.
%   state the research problem/ questions
%   state the research aims and/or research objectives
Improvements to audit2allow aim to suggest policy rules that are more
restrictive or to suggest more suitable solutions than adding new rules to the
policy.

%   state the hypotheses
%   outline the order of information in the thesis
Second chapter presents Security-Enhanced Linux, introduces SELinux policy
languages, describes auditing of security events, and describes in detail the
audit2allow utility. Third chapter discusses problems that arise with
audit2allow usage. Fourth chapter describes implementation details of selected
improvements to audit2allow.
%   outline the methodology

% ==============================================================================
\chapter{Security-Enhanced Linux and audit2allow}
% STATUS: 3
% TODO: describe SELinux, describe audit2allow, use examples, what are the
% problems of SELinux. Purpose of audit2allow, how is it used, how does it work,
% internal structure of audit2allow.

This chapter describes basic concepts of Security-Enhanced Linux, writing of
security policy, basic overview of the Linux Audit System and how it is used by
Security-Enhanced Linux, and the details of the audit2allow utility.

% ------------------------------------------------------------------------------
% TOPIC: SELinux introduction and motivation
% ----------------------------------------
% STATUS: 3
% 2.1 INTRODUCTION                                                      Y
%     2.1.1 Is SELinux useful                                           Y
% 1. Introduction
%     1.1. Benefits of running SELinux
%     1.2. Examples
\section{Security-Enhanced Linux}

% TODO: improve
Security-Enhanced Linux (SELinux) is a mandatory access control mechanism that
consists of kernel modifications and user-space tools and is a part of several
Linux distributions.

\subsection{What Problems Does SELinux Solve}
Without SELinux, operating system relies on traditinal access control methods
such as file permissions. Users can grant insecure file permissions to others or
gain access to files that they do not need:
\begin{itemize}
    \item Users can reveal sensitive information by setting world readable
        permissions on files. For example, they can set read permission for
        everyone on ssh keys in \texttt{\textasciitilde/.ssh/} directory.
    \item Processes can change security properties: mail client can make user's
        mail readable by other users.
    \item Processes inherit user's rights. For example, every application, even
        though it may be compromised, is able to read all user's files.
\end{itemize}

With enabled SELinux, every action is denied by default. A security policy is
written which allows individual applications to perform actions required to
function. Applications do not need to be aware of SELinux. When an action is
denied, it is reported via ``access denied'' error code to the application
\cite{centoshowto}.

%\subsection{How Does SELinux Enforce a Security Policy}
%
%\begin{figure}
%    \centering
%    \label{fig:policyenforcing}
%    \input{./figures/policy-enforcing.tex}
%    \caption{High-level process of policy enforcing}
%\end{figure}
%
%The high-level process of policy enforcing (see figure~\ref{fig:policyenforcing}):
%\begin{enumerate}
%    \item A \emph{subject} wants to perform an action upon an \emph{object}.
%    \item An \emph{Object Manager} queries the \emph{Security Server} for a
%    decision.
%    \item \emph{Security Server} consults the \emph{Security Policy}
%    and makes decision to allow or deny the action.
%\end{enumerate}
%
%For example, when process \texttt{httpd} wants to open the
%\texttt{/etc/httpd/conf/httpd.conf} file, security server in kernel allows the
%operation. It is desirable to allow \texttt{httpd} access its configuration
%files, so the SELinux policy contains rules that allow this operation. But if
%process \texttt{httpd} would want to write to the \texttt{/etc/passwd} file, the
%operation would be denied. Process \texttt{httpd} should not change the
%\texttt{/etc/passwd} file, so the rules which would allow this operation are not
%present in policy.

% ----------------------------------------
% TOPIC: SELinux components
% ----------------------------------------
% STATUS: 4
% 2.2 CORE SELINUX COMPONENTS                                           Y
%     1.3. SELinux Architecture
\subsection{SELinux Components}
% TODO: describe all parts
% TODO: introduce the image in text

\begin{figure}
    \centering
    \label{fig:selinuxcomponents}
    \input{./figures/selinux-components.tex}
    \caption{SELinux main components}
\end{figure}

SELinux userspace several tools and libraries:
\begin{description}
    \item [\texttt{libsepol} and \texttt{libsemanage}] Libraries for working
        with SELinux binary policy and policy infrastructure.
    \item [\texttt{libselinux}] API for implementing SELinux-aware applications.
    \item [\texttt{checkmodule}, \texttt{semodule\_package}, \texttt{semodule}]
        Utilities that compile the SELinux policy and loads it into the kernel.
    \item [\texttt{semanage}] Utility for configuring various parts of policy,
        for example setting contexts for TCP and UDP ports.
    \item [\texttt{restorecon} and \texttt{setfiles}] Utilities for restoring
        default context of files.
    \item [\texttt{policycoreutils}] Various utilities for working with and
        troubleshooting of SELinux.
    \item [Modified Linux Commands] Standard Linux commands such as \texttt{ls}
        or \texttt{ps} modified to support SELinux.
    \item [SELinux and proc filesystem] Userspace tools communicate with kernel
        security server via the \texttt{/proc} and \texttt{/sys/fs/selinux}
        filesystem.
    \item [Security Server] It is embedded in the kernel and it obtains the
        security policy via userspace tools.
    \item [Access Vector Cache] Caches security decision made by security
        server.
    \item [Linux Security Module Hooks] Calls SELinux Security Server.
\end{description}

% ------------------------------------------------------------------------------
\section{Basic Concepts}
% STATUS: 2
% TODO: write intro

This section describes basic access control mechanisms used in SELinux and
explains how are these mechanisms enforced.

% ----------------------------------------
% TOPIC: Subjects and objects
% ----------------------------------------
% STATUS: 4
\subsection{Subjects and Objects}
% TODO: basic description of subjects and objects, improve

There are two basic entities in SELinux:
\begin{description}
    \item [Subject] is an entity that causes information to flow among objects
        or changes the system state. Within SELinux, a subject is an active
        process that can access objects. Note that a process can also be an
        object, for example when sending signal to another process, the
        process receiving is an object.
    \item [Object] is a system resource such as file, socket, pipe, TCP or UDP
        port, network interface, semaphore or shared memory segment.  Objects
        are accessed via subjects.
\end{description}

% ----------------------------------------
% TOPIC: MAC, DAC
% ----------------------------------------
% STATUS: 3
% 2.3 MANDATORY ACCESS CONTROL (MAC)                                    Y
\subsection{Mandatory Access Control}

SELinux provides a mandatory access control mechanism that extends the
discretionary access control mechanisms present in Linux kernel.

\subsubsection{Discretionary Access Control}
Discretionary access control is defined by TCSES standard. System with DAC must
enable users to protect their data by controlling access to that data, e.g. by
setting permissions for other users or user groups.

In DAC, users make security decisions by specifying who can access their data.
The problem is that users can propagate sensitive information.

Linux implements discretionary access control. Every object has an owner that
controls access to that object. Permissions are set in three scopes: user,
group, and others. For each scope, permissions to read, write and execute can be
set.

\subsubsection{Mandatory Access Control}
Mandatory access control (MAC), defined by \emph{Trusted Computer System
Evaluation Criteria} (TCSEC) standard \cite{orangebook}, provides more
restrictions than DAC. In this type of access control, operating system can
prevent subjects from performing operations on objects. This is achieved by
attaching subjects and objects set of security attributes. When a subject
(usually a process) wants to perform an operation on an object (file, directory,
socket, etc.), operating system first examines these attributes. Security policy
is then used to determine whether this operation should be allowed or not. When
using MAC, users do not have the ability to override the security policy and
for example propagate sensitive information.

There are several implementations of MAC. Linux kernel currently contains
several security modules implemented using \emph{Linux Security Modules} (LSM)
framework \cite{lsmusage}. \emph{Security-Enhanced Linux} (SELinux), developed
by National Security Agency and Red Hat \cite{selinuxcontr}, is used in Red Hat
Enterprise Linux (RHEL), CentOS, Fedora and Android
\cite{selinuxguide,selinuxguidefedora,selinuxandroid}. \emph{AppArmor},
developed by SUSE, is used in SUSE Linux Enterprise, openSUSE and Ubuntu
\cite{apparmor,apparmorubuntu}. There are two other security modules,
\emph{Smack} and \emph{TOMOYO Linux}.

\subsubsection{SELinux and MAC}
% TODO: image with MAC hooks
When running a SELinux-enabled system, when a userspace process makes a system
call, standard file permissions are checked first. Then the Linux Security
Module hooks calls security checks in SELinux.

% ----------------------------------------
% TOPIC: SELinux users
% ----------------------------------------
% STATUS: 5
% 2.4 SELINUX USERS                                                     ?
\subsection{SELinux Users}
\label{selinuxuser}
SELinux uses its own user names that different than standard Linux user names.
Every Linux user is associated to a SELinux user. For example, Linux user
\texttt{root} is mapped to SELinux user \texttt{unconfined\_u} on Fedora 27.
There is a special SELinux user that is not mapped to any user:
\texttt{system\_u}.

Available SELinux users can be listed using the \texttt{seinfo} command:
\begin{lstlisting}
$ seinfo --user

Users: 8
   guest_u
   root
   staff_u
   sysadm_u
   system_u
   unconfined_u
   user_u
   xguest_u
\end{lstlisting}

% ----------------------------------------
% TOPIC: RBAC
% ----------------------------------------
% STATUS: 4
% 2.5 ROLE-BASED ACCESS CONTROL (RBAC)                                  ?
\subsection{Role-Based Access Control}
\label{rbac}
SELinux uses role-based access control, where every SELinux user is associated
to one or more roles. Each role can access only domain types that are associated
to that role. For example, user \texttt{system\_u} is associated to roles
\texttt{unconfined\_r} and \texttt{system\_r} on Fedora 27.

Available SELinux roles can be listed using the \texttt{seinfo} command:
\begin{lstlisting}
$ seinfo --role

Roles: 14
   auditadm_r
   dbadm_r
   guest_r
   logadm_r
   nx_server_r
   object_r
   secadm_r
   staff_r
   sysadm_r
   system_r
   unconfined_r
   user_r
   webadm_r
   xguest_r
\end{lstlisting}

% ----------------------------------------
% TOPIC: TE
% ----------------------------------------
% STATUS: 4
% 2.6 TYPE ENFORCEMENT (TE)                                             Y
%     2.6.1 Constraints                                                 ?
%     2.6.2 Bounds                                                      N
\subsection{Type Enforcement}
\label{te}
SELinux uses a type enforcement for enforcing mandatory access control. All
subjects and objects have a type associated. SELinux policy then contains rules
that describe the relationship between types.

Available SELinux types can be listed using the \texttt{seinfo} command:
\begin{lstlisting}
$ seinfo --type

Types: 4845
   abrt_t
   alsa_t
   antivirus_t
   bin_t
   cluster_t
   crond_t
   ...
\end{lstlisting}

% ----------------------------------------
% TOPIC: MLS and MCS
% ----------------------------------------
% STATUS: 2
%     4.13. Multi-Level Security (MLS)
%         4.13.1. MLS and System Privileges
%         4.13.2. Enabling MLS in SELinux
%         4.13.3. Creating a User With a Specific MLS Range
%         4.13.4. Setting Up Polyinstantiated Directories
\subsection{Multi-Level and Multi-Category Security}
\label{mls}
% TODO: improve

In addition to Type Enforcement and Role-Based Access Control, SELinux also
supports Multi-Level Security (MLS) and Multi-Category Security (MCS). Security
context is extended by level or range entry.

Security levels conform to the Bell-LaPadula model (BLP). For processes,
security levels describe subject's clearance, for objects, they describe
object's classification. Process running at certain security level can:
\begin{itemize}
    \item read and write at their current level,
    \item read only at lower levels,
    \item write only at higher levels.
\end{itemize}
This means that processes cannot read data with higher security level and cannot
leak sensitive information to the lower levels.

% ----------------------------------------
% TOPIC: SELinux context
% ----------------------------------------
% STATUS: 4
% 2.7 SECURITY CONTEXT                                                  Y
% 2. SELinux Contexts
\subsection{SELinux Security Context}
% TODO: describe parts of the context

Security decisions are made based on a \emph{security context} which must be
assigned to every subject and object. The security context is sometimes reffered
to as \emph{security label} or just \emph{label}. The security context is a
string in the following form:
\begin{lstlisting}
user:role:type[:range]
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{user}] The SELinux user (see section \ref{selinuxuser}).
    \item [\texttt{role}] The SELinux role (see section \ref{rbac}).
    \item [\texttt{type}] Used by type enforcement (see section \ref{te}).
    \item [\texttt{range}] Used by MLS or MCS (see section \ref{mls}). It is optional.
\end{description}

Example of subject security contexts:
\begin{lstlisting}
$ ps -eZ
LABEL                             PID TTY          TIME CMD
system_u:system_r:init_t:s0         1 ?        00:00:04 systemd
system_u:system_r:kernel_t:s0       2 ?        00:00:00 kthreadd
system_u:system_r:auditd_t:s0    1139 ?        00:00:00 auditd
system_u:system_r:alsa_t:s0      1164 ?        00:00:00 alsactl
...
\end{lstlisting}

Example of object security contexts:
\begin{lstlisting}
$ ls -Z /etc
               system_u:object_r:etc_t:s0 alsa
         system_u:object_r:cupsd_etc_t:s0 cups
          system_u:object_r:dhcp_etc_t:s0 dhcp
       system_u:object_r:passwd_file_t:s0 passwd
          system_u:object_r:net_conf_t:s0 resolv.conf
...
\end{lstlisting}

% ----------------------------------------
% TOPIC: subjects and objects, object classes, permissions, allow rule
% ----------------------------------------
% STATUS: 4
% 2.8 SUBJECTS                                                          Y
% 2.9 OBJECTS                                                           Y
%     2.9.1 Object Classes and Permissions                              Y
%     2.9.2 Allowing a Process Access to Resources                      Y
% 4.10 OBJECT CLASS AND PERMISSION STATEMENTS                           Y
%     4.10.1 class                                                      Y
%     4.10.2 Associating Permissions to a Class                         Y
%     4.10.3 common                                                     Y
%     4.10.4 class                                                      Y
\subsection{Object Classes}
% TODO: rewrite
% TODO: cite reference policy

Each object is assigned class identifier which specifies set of permissions that
describe what operations can object handle. For example, on Fedora 27, there are
the following classes:
\begin{lstlisting}
$ seinfo --class

Classes: 97
   blk_file
   chr_file
   dbus
   dir
   fd
   file
   filesystem
   ipc
   ...
\end{lstlisting}

Each class is associated a set of permissions. For example, on Fedora 27, class
\texttt{node} provides the following permissions:
\begin{lstlisting}
$ seinfo --class node -x

Classes: 1
   class node
{
	dccp_send
	enforce_dest
	tcp_recv
	rawip_send
	tcp_send
	udp_recv
	dccp_recv
	sendto
	udp_send
	recvfrom
	rawip_recv
}
\end{lstlisting}
SELinux object classes maps to the kernel object classes (files, sockets, etc.)
and userspace objects (for X-Windows or D-Bus).

% ----------------------------------------
% TOPIC: labeling
% ----------------------------------------
% STATUS: 3
%     2.9.3 Labeling Objects                                            Y
%         2.9.3.1 Labeling Extended Attribute Filesystems               Y
%             2.9.3.1.1 Copying and Moving Files                        Y
%         2.9.3.2 Labeling Subjects                                     Y
%     2.9.4 Object Reuse                                                N
% 2.10 COMPUTING SECURITY CONTEXTS                                      Y
%     2.10.1 Security Context Computation for Kernel Objects            Y
%         2.10.1.1 Process                                              Y
%         2.10.1.2 Files                                                Y
%         2.10.1.3 File Descriptors                                     N
%         2.10.1.4 Filesystems                                          N
%         2.10.1.5 Network File System (nfsv4)                          N
%         2.10.1.6 INET Sockets                                         N
%         2.10.1.7 IPC                                                  N
%         2.10.1.8 Message Queues                                       N
%         2.10.1.9 Semaphores                                           N
%         2.10.1.10 Shared Memory                                       N
%         2.10.1.11 Keys                                                N
%     2.10.2 Using libselinux Functions                                 N
%         2.10.2.1 avc_compute_create and security_compute_create       N
%         2.10.2.2 avc_compute_member and security_compute_member       N
%         2.10.2.3 security_compute_relabel                             N
%     2.2. SELinux Contexts for Processes
%     2.3. SELinux Contexts for Users
\subsection{Labeling Subjects and Objects}
% TODO: write more about file contexts

Security contexts are computed by the kernel security server using several
policy statements.

\subsubsection{Labeling Processes}
The first init process usually transitions to its own unique domain, for example
\texttt{init\_t}. On fork, the child process inherits the security context of
its parent. On exec, the child process may transition to different security
context. This is achieved by type transition policy statements. SELinux-aware
processes may change context by calling \texttt{setcon} or \texttt{setexeccon}
function from \texttt{libselinux}.

\subsubsection{Labeling Files}
Security context for files is computed as follows:
\begin{description}
    \item [\texttt{user}] User is inherited from the creating process.
    \item [\texttt{role}] Role defaults to \texttt{object\_r} unless modified by
        \texttt{role\_transition} statement.
    \item [\texttt{type}] Type defaults to the type of the parent directory
        unless modified by \texttt{type\_transition} statement.
    \item [\texttt{range}/\texttt{level}] Defaults to the low/current level of
        the creating process unless modified by \texttt{range\_transition}
        statement.
\end{description}

% ----------------------------------------
% TOPIC: type transitions
% ----------------------------------------
% STATUS: 4
% 2.12 DOMAIN AND OBJECT TRANSITIONS                                    Y
%     2.12.1 Domain Transition                                          Y
%         2.12.1.1 Type Enforcement Rules                               Y
%     2.12.2 Object Transition                                          Y
%     2.1. Domain Transitions
%     4.14. File Name Transition
\subsection{Type Transitions}

% TODO explain what is domain
To run different processes in different domains, we need a way how to
\emph{transition} a process from one domain to another. To attach file a label
different than its parent's label, we need to transition an object from one type
to another. Both can be achieved using the \texttt{type\_transition} statement.

\subsubsection{Domain Transition}

Starting new process with different security context is called domain
transition. For example, \texttt{systemd} running as \texttt{init\_t} needs to
start the Apache HTTP Server as \texttt{httpd\_t}. Apache executables are
labeled \texttt{httpd\_exec\_t}. The following policy rule allows the
transition:
\begin{lstlisting}
type_transition init_t httpd_exec_t:process httpd_t;
\end{lstlisting}
The \texttt{systemd} process does not need to be aware of SELinux. Because of
the \texttt{type\_transition} rule, the \texttt{exec} call will automatically
perform a transition. There are conditions that needs to be met before the
domain transition can happen:
\begin{enumerate}
    \item The source domain has permission to transition into the target domain.
        For example:
\begin{lstlisting}
allow init_t httpd_t:process transition;
\end{lstlisting}
    \item The source domain has permission to read and execute the binary. For
        example:
\begin{lstlisting}
allow init_t httpd_exec_t:file { execute read getattr };
\end{lstlisting}
    \item The context of the executable needs to be set as an entry point into
        the target domain. For example:
\begin{lstlisting}
allow httpd_t httpd_exec_t:file entrypoint;
\end{lstlisting}
\end{enumerate}

\subsubsection{Object Transition}
When a new object is created it inherits the security context of its parent.
When it is required that the object has different context, an object transition
is required.
For example when an X server creates a file in the \texttt{/tmp} directory
(which has context \texttt{tmp\_t}), it gets context \texttt{user\_tmp\_t}. This
is achieved by the following \texttt{type\_transition} rule:
\begin{lstlisting}
type_transition xserver_t tmp_t:file user_tmp_t;
\end{lstlisting}
The X server does not need to be aware of SELinux, the kernel handles the label
automatically.

% ----------------------------------------
% TOPIC: SELinux modes
% ----------------------------------------
% STATUS: 3
% 2.15 SELINUX PERMISSIVE AND ENFORCING MODES                           Y
%     1.4. SELinux States and Modes
% TODO: write about permissive domains
\subsection{SELinux Modes of Operation}

SELinux has three modes of operation. The default mode is \emph{enforcing}. In
this mode, everything which is not allowed by the policy is denied. When a
process tries to perform an action which is not allowed by the policy, it is
logged. In \emph{permissive} mode, SELinux is not enforcing the policy, it only
logs actions. In \emph{disabled} mode, SELinux is turned off.

% ------------------------------------------------------------------------------
% TOPIC: Policy language
% ----------------------------------------
% STATUS: 2
% 4.1 INTRODUCTION                                                      Y
%     4.1.1 CIL Overview                                                Y
% 4.2 KERNEL POLICY LANGUAGE                                            Y
%     4.2.1 Policy Source Files                                         Y
%     4.2.2 Conditional, Optional and Require Statement Rules           Y
%     4.2.3 MLS Statements and Optional MLS Components                  N
%     4.2.4 General Statement Information                               Y
%     4.2.5 Section Contents                                            N
% 2.14 TYPES OF SELINUX POLICY                                          Y
%     2.14.1 Example Policy                                             N
%     2.14.2 Reference Policy                                           Y
%     2.14.3 Policy Functionality Based on Name or Type                 Y
%     2.14.4 Custom Policy                                              N
%     2.14.5 Monolithic Policy                                          Y
%     2.14.6 Loadable Module Policy                                     Y
%         2.14.6.1 Optional Policy                                      N
%     2.14.7 Conditional Policy                                         ?
%     2.14.8 Binary Policy                                              Y
%     2.14.9 Policy Versions                                            Y
% 4.17 MODULAR POLICY SUPPORT STATEMENTS                                Y
%     4.17.1 module                                                     Y
%     4.17.2 require                                                    Y
%     4.17.3 optional                                                   Y
\section{SELinux Policy}
\label{policy}
% TODO: refine intro

Security decisions made by the security server in kernel are resolved using
SELinux policy.

\subsection{TODO: Kernel Policy Language}

The policy is either monolithic (compiled from single source file) or modular.
Modular policy, which is used in Fedora and RHEL, consists of mandatory base
policy source file and loadable modules. In Fedora, almost every module contains
policy for one application or service, such as the \texttt{apache} or
\texttt{xserver} module. Some policy statements are valid only in base policy or
in policy module.

SELinux policy statements starts with a statement keyword usually followed by
several identifiers and semicolon at the end. Comments starts with a ``\#''.
Example of an allow rule:

\begin{lstlisting}
# This is an allow rule
allow httpd_t httpd_exec_t: file { ioctl read getattr lock map execute open };
\end{lstlisting}

\subsection{Policy Modules}
\label{modules}

The \texttt{module} and \texttt{require} statements are used to support policy
modules. Every policy module must start with the \texttt{module} statement.
Syntax:
\begin{lstlisting}
module module_name version;
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{module\_name}] Name of the module.
    \item [\texttt{version}] Version number in format \texttt{X.Y.Z}.
\end{description}

The \texttt{require} statement indicates what parts of policy are required from
other modules or base policy. Syntax:
\begin{lstlisting}
require { require_list }
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{require\_list}] One or more keywords followed by identifier
        separated by semicolon. Valid keywords are: \texttt{role},
        \texttt{type}, \texttt{attribute}, \texttt{user}, \texttt{bool},
        \texttt{sensitivity}, \texttt{category}, \texttt{class}.
\end{description}

Example of \texttt{module} and \texttt{require} statements:
\begin{lstlisting}
module my_module 1.2.0;

require {
    type nscd_t, nscd_var_run_t;
    class nscd { getserv getpwd getgrp gethost shmempwd shmemgrp
        shmemhost shmemserv };
}
\end{lstlisting}

% ----------------------------------------
% TOPIC: user, role and type statements
% ----------------------------------------
% STATUS: 2
% 4.3 POLICY CONFIGURATION STATEMENTS                                   ?
%     4.3.1 policycap                                                   ?
% 4.4 DEFAULT OBJECT RULES                                              Y
%     4.4.1 default_user                                                ?
%     4.4.2 default_role                                                ?
%     4.4.3 default_type                                                ?
%     4.4.4 default_range                                               ?
% 4.5 USER STATEMENTS                                                   ?
%     4.5.1 user                                                        ? 
% 4.6 ROLE STATEMENTS                                                   ?
%     4.6.1 role                                                        ?
%     4.6.2 attribute_role                                              ?
%     4.6.3 roleattribute                                               ?
%     4.6.4 allow                                                       ?
%     4.6.5 role_transition                                             ?
%     4.6.6 dominance                                                   ?
% 4.7 TYPE STATEMENTS                                                   Y
%     4.7.1 type                                                        Y
%     4.7.2 attribute                                                   Y
%     4.7.3 typeattribute                                               Y
%     4.7.4 typealias                                                   Y
%     4.7.5 permissive                                                  Y
%     4.7.6 type_transition                                             Y
%     4.7.7 type_change                                                 N
%     4.7.8 type_member                                                 N

% TODO: improve
\subsection{User, Role and Type Statements}

SELinux assigns context to objects in the system. A \emph{SELinux context}
consists of user, role, type, and optionally MLS range. In order to assign
objects security contexts, all parts of the context must be declared in policy
using user, role, and type statements.

\subsubsection{User Statements}
The \texttt{user} statement declares an identifier for an SELinux user. Syntax:
\begin{lstlisting}
user seuser_id roles role_id;
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{seuser\_id}] SELinux user identifier.
    \item [\texttt{role\_id}] One or more role identifiers.
\end{description}

% TODO example?

\subsubsection{Role Statements}
The \texttt{role} statement either declares an identifier for an SELinux role or
associates a role to one or more types. Syntax:
\begin{lstlisting}
role role_id;
role role_id types type_id;
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{role\_id}] SELinux role identifier.
    \item [\texttt{type\_id}] One or more type identifiers.
\end{description}

% TODO example?

\subsubsection{Type Statements}
The \texttt{type} statement declares an identifier for an SELinux type. Type
identifiers usually ends with '\texttt{\_t}' to distinguish them from attribute
identifiers. Syntax:
\begin{lstlisting}
type type_id [alias alias_id] [, attribute_id];
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{type\_id}] SELinux type identifier.
    \item [\texttt{alias\_id}] One or more optional aliases declared by the
        \texttt{typealias} statement.
    \item [\texttt{attribute\_id}] One or more optional attributes declared by
        the \texttt{attribute} statement.
\end{description}

The \texttt{attribute} statement declares an identifier for a group of type
identifiers. Syntax:
\begin{lstlisting}
attribute attribute_id;
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{attribute\_id}] SELinux attribute identifier.
\end{description}

% TODO example?

% TODO typeattribute?
% TODO typealias?
% TODO permissive?

% ----------------------------------------
% TOPIC: AV rules
% ----------------------------------------
% STATUS: 2
% 4.9 ACCESS VECTOR RULES                                               Y
%     4.9.1 allow                                                       Y
%     4.9.2 dontaudit                                                   Y
%     4.9.3 auditallow                                                  Y
%     4.9.4 neverallow                                                  Y
\subsection{Access Vector Rules}
\label{avrules}

The AV rules are basic policy rules that control what access do processes get.
The \texttt{allow} rule grants process an access to an object. Syntax:
\begin{lstlisting}
allow source_type target_type:class perm_set;
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{source\_type}] One or more type or attribute identifiers.
    \item [\texttt{target\_type}] One or more type or attribute identifiers.
        When the target type is same as source type, \texttt{self} keyword can
        be used instead of target type.
    \item [\texttt{class}] One or more object classes.
    \item [\texttt{perm\_set}] One or more permissions.
\end{description}
Example:
\begin{lstlisting}
allow httpd_t samba_share_t:file { getattr open read };
\end{lstlisting}

There are three other AV rules:
\begin{description}
    \item [\texttt{dontaudit}] Stops auditing of denials. It is used when the
        denial is expected to happen and does not cause any issues. The
        \texttt{dontaudit} rules help to keep audit logs clean.
    \item [\texttt{auditallow}] Audits the event. Note that standard
        \texttt{allow} is also needed.
    \item [\texttt{neverallow}] Compiler statement that stops compilation if
        this rule is found somewhere in policy. It is used for marking rules
        that may be unsecure.
\end{description}

% ----------------------------------------
% TOPIC: Extended permission AV rules
% ----------------------------------------
% STATUS: 3
\subsection{Extended Permission Access Vector Rules}
\label{extavrules}

Since policy version 30, there are extended permission access vector (AV) rules
that expand the permission sets. Standard access vector rules operates with
32~bit permission sets, extended permission AV rules adds arbitrary number of
256~bit increments. Extended permission AV rules are currently (as of policy
version 31) used only for ioctl whitelisting, but they provide generic tool that
can be used in future for more granular control over an operation
\cite{selinuxmailxperms}.

The format of extended permission AV rules is \cite{xpermrules}:
\begin{lstlisting}
rule_name source_type target_type : class operation xperm_set;
\end{lstlisting}
where:
\begin{description}
    \item [\texttt{rule\_name}] is one of the following: \texttt{allowxperm},
        \texttt{dontauditxperm}, \texttt{auditallowxperm}, or
        \texttt{neverallowxperm}. The meaning is same as standard AV rules. The
        \texttt{allowxperm} rule allows the access, the \texttt{dontauditxperm}
        rule denies and logs the access, the \texttt{auditallowxperm} allows and
        logs the access, and the \texttt{neverallowxperm} rules is a compiler
        statement to prevent unsecure rules from appearing in policy.
    \item [\texttt{source\_type}, \texttt{target\_type}, \texttt{class}] are
        source type, target type, and object class, same as with standard AV
        rule.
    \item [\texttt{operation}] is a single keyword defining the operation to be
        implemented by the rule. As of policy version 31, only the
        \texttt{ioctl} operation is supported. In contrast to permissions in
        standard access vector rules, each extended permission AV rule has only
        one operation (standard AV rules can have many permissions).
    \item [\texttt{xperm\_set}] are extended permissions represented by numeric
        values. The meaning of values depends on the operation. Values can be
        written in decimal or hexadecimal form, for example \texttt{42} or
        \texttt{0x2a}. Multiple values must be separated by space and enclosed
        in braces, for example \texttt{\{ 1 2 3 \}}. Value ranges are supported,
        for example \texttt{50-60}. To allow all values except for those
        explicitly listed, the complement operator can be used, for example
        \texttt{\textasciitilde \{ 1 2 3 \}}.
\end{description}

Example of an extended permission AV rule:
\begin{lstlisting}
allowxperm my_app_t my_socket_t : tcp_socket ioctl { 20 30 0x40 50-60 };
\end{lstlisting}
This rule allows a process running as \texttt{my\_app\_t} to call \texttt{ioctl}
on a TCP socket labeled \texttt{my\_socket\_t} with parameters 20, 30, 64, or
any number from 50 to 60.

\subsubsection{Filtering \texttt{ioctl} System Call}
Filtering ioctl calls is as of policy version 31 the only implementation of
extended permission AV rules. For ioctl calls, the operation keyword is
\texttt{ioctl}.

When there is only \texttt{allow} rule for particular source and target context
and object class, all ioctl calls are allowed. With additional
\texttt{allowxperm} rule, only ioctl calls with parameters allowed by the
\texttt{allowxperm} rules are allowed. The \texttt{allowxperm} rule alone has
no effect, for ioctl filtering, both \texttt{allow} and \texttt{allowxperm}
rules must be present.

% ----------------------------------------
% TOPIC: Conditional policy
% ----------------------------------------
% STATUS: 2
% 4.11 CONDITIONAL POLICY STATEMENTS                                    Y
%     4.11.1 bool                                                       Y
%     4.11.2 if                                                         Y
%     4.6. Booleans
%         4.6.1. Listing Booleans
%         4.6.2. Configuring Booleans
%         4.6.3. Shell Auto-Completion
\subsection{Conditional Policy}
% TODO: improve, write more stuff

SELinux policy allows turning on and off set of policy statements without the
need for reloading policy. Conditional policy is defined using the \texttt{bool}
statement that defines a condition. Then a \texttt{if}/\texttt{else} construct
is used. Example:
\begin{lstlisting}
bool allow_execmem false;

if (allow_execmem) {
    allow sysadm_t self:process execmem;
}
\end{lstlisting}
Booleans can be turned on and off using the \texttt{semanage boolean} command.

% ----------------------------------------
% TOPIC: Networking
% ----------------------------------------
% STATUS: 2
% 2.21 SELINUX NETWORKING SUPPORT                                       N
%     2.21.1 SECMARK                                                    N
%     2.21.2 NetLabel - Fallback Peer Labeling                          N
%     2.21.3 NetLabel - CIPSO                                           N
%     2.21.4 Labeled IPSec                                              N
%     2.21.4.1 Configuration Examples                                   N
% 4.16 NETWORK LABELING STATEMENTS                                      Y
%     4.16.1 IP Address Formats                                         Y
%         4.16.1.1 IPv4 Address Format                                  Y
%         4.16.1.2 IPv6 Address Formats                                 Y
%     4.16.2 netifcon                                                   Y
%     4.16.3 nodecon                                                    Y
%     4.16.4 portcon                                                    Y
\subsection{Labeling Network Objects}

SELinux policy supports labeling of the following network objects:
\begin{description}
    \item [Network ports] TCP or UDP port numbers.
    \item [Network nodes] Represented by IP addresses and subnet masks.
    \item [Network interfaces] Interfaces managed by \texttt{ifconfig} (e.g.
        \texttt{eth0}).
\end{description}

The \texttt{netifcon} statement labels network interface statements. Syntax:
\begin{lstlisting}
netifcon netif_id netif_context packet_context
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{netif\_id}] Name of the network interface (e.g.
        \texttt{eth0}).
    \item [\texttt{netif\_context}] Security context of the interface.
    \item [\texttt{packet\_context}] Security context of the packets. This is
        not currently used.
\end{description}
Example:
\begin{lstlisting}
netifcon eth0 system_u:object_r:netif_t:s0 system_u:object_r:netif_t:s0
\end{lstlisting}

The \texttt{nodecon} statement labels network addresses. Syntax:
\begin{lstlisting}
nodecon subnet netmask node_context
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{subnet}] The IP address.
    \item [\texttt{netmask}] The subnet mask.
    \item [\texttt{node\_context}] Security context of the node.
\end{description}
Example:
\begin{lstlisting}
nodecon ff00:: ff00:: system_u:object_r:multicast_node_t:s0
\end{lstlisting}

The \texttt{portcon} statement labels TCP and UDP ports. Syntax:
\begin{lstlisting}
portcon protocol port_number port_context
\end{lstlisting}
Where:
\begin{description}
    \item [\texttt{protocol}] Either \texttt{udp} or \texttt{tcp}.
    \item [\texttt{port\_number}] Port number or a range.
    \item [\texttt{port\_context}] Security context of the port.
\end{description}
Example:
\begin{lstlisting}
portcon tcp 22 system_u:object_r:ssh_port_t:s0
\end{lstlisting}

% ----------------------------------------
% TOPIC: Interfaces
% ----------------------------------------
% STATUS: 0
\subsection{TODO: Interfaces}
\label{interfaces}
TODO

% ----------------------------------------
% TOPIC: File contexts
% ----------------------------------------
% STATUS: 3
%     4.7. SELinux Contexts – Labeling Files
%         4.7.1. Temporary Changes: chcon
%         4.7.2. Persistent Changes: semanage fcontext
%     4.8. The file_t and default_t Types
%     4.9. Mounting File Systems
%         4.9.1. Context Mounts
%         4.9.2. Changing the Default Context
%         4.9.3. Mounting an NFS Volume
%         4.9.4. Multiple NFS Mounts
%         4.9.5. Making Context Mounts Persistent
%     4.10. Maintaining SELinux Labels
%         4.10.1. Copying Files and Directories
%         4.10.2. Moving Files and Directories
%         4.10.3. Checking the Default SELinux Context
%         4.10.4. Archiving Files with tar
%         4.10.5. Archiving Files with star
% TODO: chapters from selinux configuration section
% TODO: write it

\section{File Contexts}

When accessing files, SELinux relies on labels stored with those files to make a
security decision. SELinux labels can be viewed using the \texttt{ls -Z}
command:
\begin{lstlisting}
$ ls -Z
unconfined_u:object_r:user_home_t:s0    testdir
unconfined_u:object_r:user_home_t:s0    testfile
\end{lstlisting}
Labels are stored in extended attributes in the security namespace
\cite{xattrman}:
\begin{lstlisting}
$ getfattr -n security.selinux testfile
# file: testfile
security.selinux="unconfined_u:object_r:user_home_t:s0"
\end{lstlisting}

\subsection{Temporary Changes}
The \texttt{chcon} command changes the SELinux context of files. User must have
the permissions to relabel files. The changes made by \texttt{chcon} are
overwritten by a file system relabel or running of \texttt{restorecon}.

\subsection{Type Transition}
There are rules in policy that specifies the context of files created by
processes. For example, when process running with \texttt{httpd\_t} context
creates a file in directory with \texttt{var\_run\_t} context, the file will get
context \texttt{httpd\_var\_run\_t}:
% TODO explain
\begin{lstlisting}
$ sesearch -T -s httpd_t -t var_run_t -c file
type_transition httpd_t var_run_t:file httpd_var_run_t;
\end{lstlisting}

\subsection{File Context Configuration Files}
There are situations when files get label that is different than the default
one:
\begin{enumerate}
    % TODO fix
    \item When moving files, label is preserved. This does not happen when
        copying files because new file is always created.
    \item When SELinux is disabled, labels are not assigned to files.
    \item When policy is changed (for example when a module is unloaded), there
        may be some files left with type that is no longer defined in policy.
\end{enumerate}
For these situations, there is a \texttt{file\_contexts} file which specifies
default contexts for every file. Example:
\begin{lstlisting}
/run/.*         --  system_u:object_r:var_run_t:s0
/var/.*	        --  system_u:object_r:var_t:s0
/etc/.*	        --  system_u:object_r:etc_t:s0
/lib/.*	        --  system_u:object_r:lib_t:s0
/usr/.*\.cgi    --  system_u:object_r:httpd_sys_script_exec_t:s0
/root(/.*)?     --  system_u:object_r:admin_home_t:s0
/dev/[0-9].*    -c  system_u:object_r:usb_device_t:s0
/dev/.*tty[^/]* -c  system_u:object_r:tty_device_t:s0
\end{lstlisting}
The \texttt{-{}-} is means every file type, \texttt{-c} means character device.
The \texttt{restorecon} utility is used to restore security contexts on files.

\subsubsection{Building File Context Files}
Utilities such as \texttt{restorecon} or \texttt{setfiles} uses several files to
restore default contexts of files:
\begin{description}
    \item [\texttt{file\_contexts}] Contains default contexts for files.
    \item [\texttt{file\_contexts.homedirs}] Contains default contexts for files
        inside user home directories.
    \item [\texttt{file\_contexts.local}] Contains local modifications of
        default file contexts.
    \item [\texttt{file\_contexts.subs} and \texttt{file\_contexts.subs\_dist}]
        Contains file name substitutions. For example, these files can specify
        that \texttt{/usr/lib64} should be treated the same way as
        \texttt{/usr/lib}.
\end{description}

\begin{figure}
    \centering
    \label{fig:filecontexts}
    \input{./figures/filecontexts.tex}
    \caption{File Context Files}
\end{figure}

These files are created when building policy, see figure \ref{fig:filecontexts}.
All \texttt{.fc} files from base policy and from policy modules are used to
build the \texttt{file\_contexts.template} file. This file may contain rules
that has special keywords, such as \texttt{HOME\_ROOT}, \texttt{HOME\_DIR}, or
\texttt{USER}. All rules without special keyword are used to build the
\texttt{file\_contexts} file used directly by utilities such as
\texttt{restorecon} or \texttt{setfiles}.

Rules with special keywords are used to build the \texttt{homedir\_template}
file. These rules are asssociated with users home directories and needs to be
expanded for individual users using the \texttt{genhomedircon} utility. For
example the following \texttt{homedir\_template} entry:
\begin{lstlisting}
HOME_DIR/\.ssh(/.*)?        system_u:object_r:ssh_home_t:s0
\end{lstlisting}
would be expanded to the following rules:
\begin{lstlisting}
/home/[^/]*/\.ssh(/.*)?     system_u:object_r:ssh_home_t:s0
/root/\.ssh(/.*)?           system_u:object_r:ssh_home_t:s0
\end{lstlisting}
Expanded rules are then stored in the \texttt{file\_contexts.homedirs} file and
used by \texttt{restorecon} and \texttt{setfiles} utilities.

\subsection{Changing File Context Files}

The \texttt{file\_contexts} file can be changed using the \texttt{semanage
fcontext} command. For example:
\begin{lstlisting}
# semanage fcontext -a -t samba_share_t /etc/myfile
# semanage fcontext -l -C
SELinux fcontext    type        Context
/etc/myfile         all files   system_u:object_r:samba_share_t:s0
\end{lstlisting}
In this example, new file contexts entry was added. The rule states that file
\texttt{/etc/myfile} should obtain context
\texttt{system\_u:object\_r:samba\_share\_t:s0}.

% ------------------------------------------------------------------------------
% TOPIC: Auditing
% ----------------------------------------
% STATUS: 2
% 2.16 AUDITING SELINUX EVENTS                                          Y
%     2.16.1 AVC Audit Events                                           Y
%     2.16.2 General SELinux Audit Events                               Y
% TODO: write intro text
\section{Auditing Security Events}

The \emph{Linux Audit system} provides an auditing system for tracking
security-relevant system events. It is used to track file access, monitor system
calls, record commands run by user, record failed login attempts and others
\cite{secguide}. The Linux Audit system does not provide additional security by
itself, it can be only used to discover security violations.

The Linux Audit system consists of kernel and userspace part. Kernel filters
events and sends them to the \emph{audit daemon}. Audit daemon then writes the
received events to log file. There are several userspace tools used for
interacting with the audit system and for working with the log file.

\subsection{Audit and SELinux}

In Fedora and RHEL, SELinux uses the Linux Audit system to log security events.
When a process tries to perform operation without the permissions, an
\emph{Access Vector Cache} (AVC) denial message is logged using the audit daemon
\cite{selinuxguide}. This message can be then processed by tools such as
\texttt{setroubleshoot} or \texttt{audit2allow}.

Every AVC message contains information about \emph{source context} (the context
of the process), \emph{object class} (for example file), and \emph{target
context} (the context of the object). For example, when a process \texttt{httpd}
running in context \texttt{unconfined\_u:system\_r:httpd\_t:s0} is trying to
perform the \texttt{getattr} operation on file \texttt{/var/www/html/file1} with
context \texttt{system\_u:object\_r:samba\_share\_t:s0} and fails, the following
AVC message is generated:

\begin{lstlisting}
type=AVC msg=audit(1223024155.684:49): avc:  denied  { getattr }
for pid=2000 comm="httpd" path="/var/www/html/file1" dev=dm-0
ino=399185 scontext=unconfined_u:system_r:httpd_t:s0
tcontext=system_u:object_r:samba_share_t:s0 tclass=file
\end{lstlisting}

% ------------------------------------------------------------------------------
% TOPIC: Troubleshooting
% ----------------------------------------
% STATUS: 1
% 11. Troubleshooting
%     11.1. What Happens when Access is Denied
%     11.2. Top Three Causes of Problems
%         11.2.1. Labeling Problems
%         11.2.2. How are Confined Services Running?
%         11.2.3. Evolving Rules and Broken Applications
%     11.3. Fixing Problems
%         11.3.1. Linux Permissions
%         11.3.2. Possible Causes of Silent Denials
%         11.3.3. Manual Pages for Services
%         11.3.4. Permissive Domains
%         11.3.5. Searching For and Viewing Denials
%         11.3.6. Raw Audit Messages
%         11.3.7. sealert Messages
%         11.3.8. Allowing Access: audit2allow
\section{Troubleshooting SELinux}
% TODO: write about SELinux problems and troubleshooting
% SELinux denial - what happens, logs
% auditd
% setroubleshootd
% labeling problems
% services running with wrong context
% ports
% linux perms
% silent denials - dontaudit rules
% permissive domains
% viewing denials
% sealert
% audit2allow

When SELinux denies access that is requested by a process, the process may fail
to function normally and reports error or crashes. Determining if the failure is
related to SELinux is done by switching whole SELinux or just one domain into
permissive mode. For example, for debugging \texttt{httpd} it is advised to set
the \texttt{httpd\_t} domain into permissive mode:
\begin{lstlisting}
# semanage permissive -a httpd_t
\end{lstlisting}
SELinux denials caused by the \texttt{httpd\_t} domain would still be logged but
not enforced.

SELinux denials are logged using the Linux Audit System (the default option in
Fedora and RHEL) or using the system log at \texttt{/var/log/messages}. The
\texttt{setroubleshootd} daemon (if running) analyzes SELinux denials and
provides suggestions for resolving the problem using various plugins.

% ------------------------------------------------------------------------------
\section{The audit2allow Utility}
% STATUS: 3
% TODO: improve the structure
The \emph{audit2allow} is a userspace tool that scans the AVC messages and
generates SELinux policy snippets based on them.

\subsection{Purpose of audit2allow}
The audit2allow is tool designed both for system administrators and SELinux
policy developers. System administrators use audit2allow to analyze SELinux
denials and to add policy new policy modules. The audit2allow utility also
suggests other options to resolve denials, such as turning on a boolean.

Policy developers can use audit2allow for creating basis for new policy module.
When writing policy for their program, they can run the program's test suite in
permissive mode, collect SELinux denials, create policy module, and then
manually finish the policy module. Policy developers can use the
\texttt{-{}-reference} option to generate policy using macros.

\subsection{Basic Mode of Operation}
% STATUS: 4
In default mode, audit2allow scans the AVC denial messages and generates policy
rules which allows the operations that were denied. For example, when the
\texttt{httpd} process tries to perform \texttt{getattr} operation on the
\texttt{/var/www/html/file1} file, the following AVC message is generated:
\begin{lstlisting}
type=AVC msg=audit(1223024155.684:49): avc:  denied  { getattr }
for pid=2000 comm="httpd" path="/var/www/html/file1" dev=dm-0
ino=399185 scontext=unconfined_u:system_r:httpd_t:s0
tcontext=system_u:object_r:samba_share_t:s0 tclass=file
\end{lstlisting}
The audit2allow utility would generate the following policy rule:
\begin{lstlisting}
allow httpd_t samba_share_t:file getattr;
\end{lstlisting}
The audit2allow utility is able process multiple AVC denial messages, deal with
duplicates, and output all rules based on fields in AVC denial messages.

\subsection{Command-Line Options}
% STATUS: 4
The audit2allow utility is able to read AVC messages from stdin, dmesg, audit
log, or arbitrary file (see \texttt{-{}-dmesg}, \texttt{-{}-all}, and
\texttt{-{}-input} options). There is \texttt{-{}-boot} option which loads only
messages generated since last boot and \texttt{-{}-lastreload} option which
loads only messages since last policy reload.

The audit2allow utility can output the policy rules directly to stdout or file,
or create a policy module which can be loaded directly into the policy (see
\texttt{-{}-module}, \texttt{-M}, and \texttt{-{}-output} options).

The audit2allow utility is using currently loaded policy (or any other policy
specified in the \texttt{-{}-policy} option) to get more information about the
denials.  For example, audit2allow suggests turning on a boolean that would
allow the denied operations.

When run with the \texttt{-{}-reference} option, audit2allow tries to match the
denials against defined interfaces. Example of audit2allow output without the
\texttt{-{}-reference} option:
\begin{lstlisting}
#============= httpd_t ==============
allow httpd_t samba_share_t:file getattr;
\end{lstlisting}
Example of audit2allow output with the \texttt{-{}-reference} option:
\begin{lstlisting}
require {
	type httpd_t;
}

#============= httpd_t ==============
samba_read_share_files(httpd_t)
\end{lstlisting}
The audit2allow found an interface which contained the same allow
rule. Interfaces creates more readable code but can contain more rules that are
necessary.

The \texttt{-{}-why} option does not output any policy rules but provides a text
description of why the access was denied. Example of \texttt{audit2allow
-{}-why} output:
\begin{lstlisting}
type=AVC msg=audit(1223024155.684:49): avc: denied { getattr }
for pid=2000 comm="httpd" path="/var/www/html/file1" dev=dm-0
ino=399185 scontext=unconfined_u:system_r:httpd_t:s0
tcontext=system_u:object_r:samba_share_t:s0 tclass=file

    Was caused by:
        Missing type enforcement (TE) allow rule.

        You can use audit2allow to generate a loadable module
        to allow this access.
\end{lstlisting}

The \texttt{-{}-dontaudit} option generates \texttt{dontaudit} rules instead of
\texttt{allow} rules (see section~\ref{avrules}).

\subsection{How Does audit2allow Work}
% STATUS: 3
The audit2allow first collects audit messages from various sources. Messages are
stored based on their type and then parsed. Every AVC denial message is analyzed
together with binary policy file to find out the reason of denial.

From AVC denial messages, source contexts, target contexts, object classes, and
permissions are extracted and converted into \emph{access vector sets}. Each
access vector has unique source context, target context, and object class
combination. Permissions from multiple AVC messages are merged into one access
vector. Example of an access vector set:
\begin{lstlisting}
{
    ('unconfined_u:system_r:httpd_t:s0',
     'system_u:object_r:samba_share_t:s0',
     'file'): [ 'getattr', 'open' ],
    ('unconfined_u:system_r:httpd_t:s0',
     'system_u:object_r:sssd_conf_t:s0',
     'file'): [ 'getattr' ],
}
\end{lstlisting}

Each access vector is then converted into an allow rule. All rules are then
printed to the output, optionally with \texttt{require} section. Example:
\begin{lstlisting}
allow httpd_t samba_share_t:file { getattr, open };
allow httpd_t sssd_conf_t:file getattr;
\end{lstlisting}

Various other information is stored during processing. The audit2allow prints
comments with helpful messages.

\subsection{Implementation of audit2allow}
% STATUS: 4
% TODO: link to upstream repo on github
The audit2allow utility is part of SELinux userspace. It is written mostly in
Python with several parts written in C. It uses \texttt{sepolgen} and
\texttt{sepolicy} Python modules and \texttt{libselinux} and \texttt{libsepol}
libraries.

Main script, \texttt{audit2allow}, parses command-line options, retrieves audit
messages, and prints the output.  Main logic of converting AVC denial messages
to access vector rules is implemented in package \texttt{sepolgen}.

The \texttt{sepolgen} package contains the following modules:
\begin{description}
    \item [\texttt{audit}] Defines classes for various audit messages, contains
        audit message parser.
    \item [\texttt{access}] Defines access vectors and access vector sets.
    \item [\texttt{policygen}] Creates policy rules based on access vectors.
    \item [\texttt{refpolicy}] Contains classes that represent the policy
        statements.
    \item [\texttt{output}] Outputs the generated rules.
    \item [Other modules] There are several other modules which are either not
        significant (e.g. the \texttt{utils} package) or used only for
        generating policy using interfaces (e.g. the \texttt{interfaces}
        package).
\end{description}

\subsubsection{The audit2allow Script}
% STATUS: 4
% parse options
% load policy
    % init the audit2why C module
% read input
    % creates audit parser
    % reads messages
    % feeds them to the parser
% process input
    % filters messages if neccessary
    % converts messages to access vectors
% output
    % output audit2why if selected
    % creates policy generator
    % sets options to the generator
    % adds AVs to the generator
    % writes the output

The main script does the following steps:
\begin{enumerate}
    \item Parse command-line arguments and check potential conflicts.
    \item Read audit messages. Create \texttt{AuditParser} instance and feed it
        the messages.
    \item Filter the messages (if specified by the \texttt{-{}-type} option) and
        convert them to access vectors.
    \item Create and setup a \texttt{PolicyGenerator} instance, feed it the
        access vectors, and convert them to policy rules.
    \item Write the output.
\end{enumerate}

\subsubsection{The audit Module}
% STATUS: 4
% convenience functions
% AuditMessage class
    % base class for all messages
% InvalidMessage class
% PathMessage class
% PolicyLoadMessage class
% DaemonStartMessage class
% ComputeSidMessage class
% AVCMessage class
    % from_split_string
    % analyze
% AuditParser class
    % parse_file, parse_string
    % to_role, to_access
% AVCTypeFilter
% ComputeSidTypeFilter

The \texttt{audit} module is used for parsing audit messages. It is not a
general purpose audit parsing library, it is meant to parse mainly AVC messages
and policy load messages.

The \texttt{AuditParser} class reads strings and creates objects of appropriate
type for each message. The \texttt{AuditMessage} class is the base class for all
message types. The \texttt{AVCMessage} class represents AVC denials and is used
for generating access vectors.

After parsing of AVC message, the denial is analyzed in \texttt{audit2why}
module (from \texttt{libselinux} library). The \texttt{audit2why} module tries
to find out the reason of the denial by analyzing the policy. The module is
written in C and uses the \texttt{libsepol} library. Each message is then
converted to an access vector from the \texttt{access} module. AVC denial
messages can be filtered using regular expressions via the
\texttt{AVCTypeFilter} class. Only messages that match are processed.

Policy load messsages are important with the \texttt{-{}-lastreload}
command-line option. The \texttt{AuditParser} then processes only messages after
last policy load message.

\subsubsection{The access Module}
% STATUS: 4
% AccessVector
    % basic representation of access
    % single source and target type, single object class, set of permissions
% AccessVectorSet
    % used for storing AVs
    % AVs with same source and target type and class are merged
    % add() adds AV to the set
% RoleTypeSet

The \texttt{access} module defines the \texttt{AccessVector} and
\texttt{AccessVectorSet} classes. Access vector is a basic representation of an
access in SELinux. It contains single source and target type, single object
class, and set of permissions. Every AVC denial message can be converted into an
access vector. For example this AVC denial message:
\begin{lstlisting}
type=AVC msg=audit(1223024155.684:49): avc:  denied  { getattr }
for pid=2000 comm="httpd" path="/var/www/html/file1" dev=dm-0
ino=399185 scontext=unconfined_u:system_r:httpd_t:s0
tcontext=system_u:object_r:samba_share_t:s0 tclass=file
\end{lstlisting}
would be converted into the following access vector:
\begin{lstlisting}
{
    source_context: 'unconfined_u:system_r:httpd_t:s0',
    target_context: 'system_u:object_r:samba_share_t:s0',
    object_class: 'file',
    permissions: [ 'getattr' ]
}
\end{lstlisting}

Multiple access vectors are aggregated in access vector sets. Access vectors
that share the same source and target type and object class are merged together
so that there are no duplicates. For example, if we add the following access
vector:
\begin{lstlisting}
{
    source_context: 'unconfined_u:system_r:httpd_t:s0',
    target_context: 'system_u:object_r:samba_share_t:s0',
    object_class: 'file',
    permissions: [ 'open', 'read' ]
}
\end{lstlisting}
to the access vector above, they would be merged into the following access
vector (they share source and target context and object class):
\begin{lstlisting}
{
    source_context: 'unconfined_u:system_r:httpd_t:s0',
    target_context: 'system_u:object_r:samba_share_t:s0',
    object_class: 'file',
    permissions: [ 'getattr', 'open', 'read' ]
}
\end{lstlisting}

Access vector sets serves as a basis for generating policy access vector rules
in \texttt{policygen} module.

\subsubsection{The policygen Module}
% STATUS: 4
% PolicyGenerator
    % generates policy module from access vectors
    % has several options
    % set_gen_refpol()
    % set_gen_requires()
    % set_gen_explain()
    % set_gen_dontaudit()
    % add_access()
% explain_access()
% call_interface()
% InterfaceGenerator
% gen_requires()

The \texttt{policygen} module defines \texttt{PolicyGenerator} class that
generates policy module from access vectors. The \texttt{PolicyGenerator}
converts access vector set into SELinux policy statements. For example, this
access vector:
\begin{lstlisting}
{
    source_context: 'unconfined_u:system_r:httpd_t:s0',
    target_context: 'system_u:object_r:samba_share_t:s0',
    object_class: 'file',
    permissions: [ 'getattr', 'open', 'read' ]
}
\end{lstlisting}
would be converted into the following policy statement:
\begin{lstlisting}
allow httpd_t samba_share_t:file { getattr open read };
\end{lstlisting}

The \texttt{PolicyGenerator} uses objects from the \texttt{refpolicy} module to
represent policy statements. The \texttt{PolicyGenerator} provides several
configuration methods:
\begin{description}
    \item [\texttt{set\_gen\_refpol()}] Turn on interface generation (see
        section \ref{interfaces}).
    \item [\texttt{set\_gen\_requires()}] Add module requires that are
        neccessary for creating a standalone policy module (see section
        \ref{modules}).
    \item [\texttt{set\_gen\_explain()}] Add comments explaining why were the
        policy statements generated.
    \item [\texttt{set\_gen\_dontaudit()}] Generate \texttt{dontaudit} rules
        instead of \texttt{allow} rules (see section \ref{avrules}).
\end{description}
The output of the \texttt{PolicyGenerator} is a tree-like structure containing
generated statements. The \texttt{output} module then just prints out every
statement.

\subsubsection{The refpolicy Module}
% STATUS: 3
% PolicyBase
% Node
% Leaf
% walktree, walknode, list_to_space_str, list_to_comma_str
% IdSet
% SecurityContext
% ObjectClass
% TypeAttribute, RoleAttribute
% Role, Type, TypeAlias
% Attribute, AttributeRole
% AVRule
% TypeRule, TypeBound
% RoleAllow, RoleType
% ModuleDeclaration
% Conditional, Bool
% InitialSid, GenfsCon, FilesystemUse
% PortCon, NodeCon, NetifCon, PirqCon, IomemCon, IoportCon
% print_tree
% Headers
% Module
% Interface, TunablePolicy, Template, IfDef, InterfaceCall, OptionalPolicy,
% SupportMacros, Require
% ObjPermSet, ClassMap
% Comment
This module contains classes that represent SELinux policy statements. The
\texttt{Node} and \texttt{Leaf} classes are base classes for all policy
statements. Every statement is either a node that is a parent of other
statements (for example the \texttt{Module} class), or a leaf (for example the
\texttt{AVRule} class). The \texttt{refpolicy} module contains functions for
traversing trees made of nodes and leaves. These functions are used when
printing statements in the \texttt{output} module.

The \texttt{IdSet} class represents set of arbitrary identifiers and is used by
many statements for storing permissions and other sets. The
\texttt{SecurityContext} class represents a SELinux security context. Classes
such as \texttt{TypeAttribute}, \texttt{RoleAttribute}, \texttt{Role},
\texttt{Type}, and others represent policy statements as described in section
\ref{policy} and are used mainly for interface generation.

For basic operation mode, the following classes are used: \texttt{AVRule},
\texttt{ModuleDeclaration}, \texttt{Module}, and \texttt{Require}. The
\texttt{AVRule} class contains the following attributes:
\begin{description}
    \item [\texttt{src\_types}] \texttt{IdSet()} of source types.
    \item [\texttt{tgt\_types}] \texttt{IdSet()} of source types.
    \item [\texttt{obj\_classes}] \texttt{IdSet()} of object classes.
    \item [\texttt{perms}] \texttt{IdSet()} of permissions.
    \item [\texttt{rule\_type}] One of the following: \texttt{ALLOW},
        \texttt{DONTAUDIT}, \texttt{AUDITALLOW}, or \texttt{NEVERALLOW}.
\end{description}
Class \texttt{Module} serves only as a node that is parent to all statements
inside a module. Class \texttt{ModuleDeclaration} represents the
\texttt{module} statement and is generated with the \texttt{-{}-module} option.
Class \texttt{Require} represent the \texttt{require} statement inside policy
modules and is generated with either \texttt{-{}-module} or \texttt{-{}-require}
options.

% ----------------------------------------
% THE SELINUX NOTEBOOK
% 2.11 COMPUTING ACCESS DECISIONS                                       ?
% 2.17 POLYINSTANTIATION SUPPORT                                        N
%     2.17.1 Polyinstantiated Objects                                   N
%     2.17.2 Polyinstantiation support in PAM                           N
%         2.17.2.1 namespace.conf Configuration File                    N
%         2.17.2.2 Example Configurations                               N
%     2.17.3 Polyinstantiation support in X-Windows                     N
%     2.17.4 Polyinstantiation support in the Reference Policy          N
% 2.18 PAM LOGIN PROCESS                                                N
% 2.20 LIBSELINUX LIBRARY                                               N
% 4.12 CONSTRAINT STATEMENTS                                            ?
%     4.12.1 constrain                                                  ?
%     4.12.2 validatetrans                                              ?
%     4.12.3 mlsconstrain                                               ?
%     4.12.4 mlsvalidatetrans                                           ?
% 4.13 MLS STATEMENTS                                                   N
%     4.13.1 sensitivity                                                N
%     4.13.2 dominance                                                  N
%     4.13.3 category                                                   N
%     4.13.4 level                                                      N
%     4.13.5 range_transition                                           N
%         4.13.5.1 MLS range Definition                                 N
%     4.13.6 mlsconstrain                                               N
%     4.13.7 mlsvalidatetrans                                           N
% 4.14 SECURITY ID (SID) STATEMENT                                      N
%     4.14.1 sid                                                        N
%     4.14.2 sid context                                                N
% 4.15 FILE SYSTEM LABELING STATEMENTS                                  N
%     4.15.1 fs_use_xattr                                               N
%     4.15.2 fs_use_task                                                N
%     4.15.3 fs_use_trans                                               N
%     4.15.4 genfscon                                                   N
% 4.18 XEN STATEMENTS                                                   N
%     4.18.1 iomemcon                                                   N
%     4.18.2 ioportcon                                                  N
%     4.18.3 pcidevicecon                                               N
%     4.18.4 pirqcon                                                    N
%     1.5. Additional Resources
% SELINUX GUIDE
% 3. Targeted Policy
%     3.1. Confined Processes
%     3.2. Unconfined Processes
%     3.3. Confined and Unconfined Users
%         3.3.1. The sudo Transition and SELinux Roles
% 4. Working with SELinux
%     4.1. SELinux Packages
%     4.2. Which Log File is Used
%     4.3. Main Configuration File
%     4.4. Permanent Changes in SELinux States and Modes
%         4.4.1. Enabling SELinux
%         4.4.2. Disabling SELinux
%     4.5. Changing SELinux Modes at Boot Time
%     4.11. Information Gathering Tools
%     4.12. Prioritizing and Disabling SELinux Policy Modules
%     4.15. Disabling ptrace()
%     4.16. Thumbnail Protection
% 5. The sepolicy Suite
%     5.1. The sepolicy Python Bindings
%     5.2. Generating SELinux Policy Modules: sepolicy generate
%     5.3. Understanding Domain Transitions: sepolicy transition
%     5.4. Generating Manual Pages: sepolicy manpage
% 6. Confining Users
%     6.1. Linux and SELinux User Mappings
%     6.2. Confining New Linux Users: useradd
%     6.3. Confining Existing Linux Users: semanage login
%     6.4. Changing the Default Mapping
%     6.5. xguest: Kiosk Mode
%     6.6. Booleans for Users Executing Applications
% 7. Securing Programs Using Sandbox
%     7.1. Running an Application Using Sandbox
% 8. sVirt
%     8.1. Security and Virtualization
%     8.2. sVirt Labeling
% 9. Secure Linux Containers
% 10. SELinux systemd Access Control
%     10.1. SELinux Access Permissions for Services
%     10.2. SELinux and journald
% 12. Further Information
%     12.1. Contributors
%     12.2. Other Resources

% ==============================================================================
\chapter{Analysis}
% STATUS: 2
% TODO: improve
Several improvements to audit2allow were proposed:
\begin{enumerate}
    \item Changing label of an object instead of creating new policy rules. This
        includes checking of mislabeled files, labeling network ports, nodes,
        and interfaces.
    \item Support for new SELinux policy statements.
\end{enumerate}

% ------------------------------------------------------------------------------
\section{Mislabeled Files}
% STATUS: 2
SELinux relies on files that are correctly labeled. Sometimes, files get
mislabeled and causes AVC denials. When used for troubleshooting, audit2allow
suggests adding new rules to the policy instead of changing label of the file.

\subsection{AVC Denial Messages Caused by Mislabeled Files}
% STATUS: 2
When a process is trying to access file that is mislabeled, the operation is
usually denied (unless the process has access also to the new label). Similar
AVC denial message is generated:
\begin{lstlisting}
type=AVC msg=audit(1226270358.848:238): avc:  denied  { getattr }
for  pid=13349 comm="httpd" path="/var/www/html/index.html"
dev=dm-0 ino=218171 scontext=system_u:system_r:httpd_t:s0
tcontext=system_u:object_r:user_home_t:s0 tclass=file
\end{lstlisting}
File \texttt{/var/www/html/index.html} is mislabeled, because files in
\texttt{/var/www/html} should have context \texttt{httpd\_sys\_content\_t}. This
denial should be fixed by running \texttt{restorecon} on the file:
\begin{lstlisting}
# restorecon -v /var/www/html/index.html
Relabeled /var/www/html/index.html from unconfined_u:object_r:user_home_t:s0
to unconfined_u:object_r:httpd_sys_content_t:s0
\end{lstlisting}

When using audit2allow, the following rules are generated:
\begin{lstlisting}
allow httpd_t user_home_t:file getattr;
\end{lstlisting}
This solution is not secure because it is adding unnecessary rules to the policy
and it does not solve the real problem.

\subsection{Proposal for Improvement to audit2allow}
% STATUS: 2
The audit2allow should detect when the AVC message is caused by mislabeled file
and suggest solution using the \texttt{restorecon} utility.

There are three fields in the AVC message that can be used to detect if the file
was mislabeled: \texttt{path}, \texttt{name} and \texttt{inode}. When the
\texttt{path} field is present, audit2allow can run \texttt{matchpathcon} to get
the default context of the file and compare it with actual file context.

In many cases, the \texttt{path} field is not present, only inode number and
name of the file (without full path). In this case it is difficult to find the
full path of the file. Ryan Hallisey created solution \cite{restoreconpullreq}
that is using \texttt{locate} utility to get all files matching the name and
then stat these files to get the inode number. This solution is only partial, it
does not work on files that are not indexed in the database created by
\texttt{updatedb}.

% ------------------------------------------------------------------------------
\section{Extended Permission Access Vector Rules}
% STATUS: 0
TODO

\subsection{AVC Denials Caused by Extended Permission AV Rules}
% STATUS: 2
Suppose there are following rules present in the policy:
\begin{lstlisting}
allow src_t tgt_t : tcp_socket ioctl;
allowxperm src_t tgt_t : tcp_socket ioctl 0x42;
\end{lstlisting}
When the process tries to call \texttt{ioctl(0x1234, ...)}, the operation would
be denied, because only syscall \texttt{ioctl(0x42, ...)} is allowed. The
following AVC denial message would be generated:
\begin{lstlisting}
type=AVC msg=audit(1515017775.689:1722): avc:  denied  { ioctl } for
pid=14587 comm="test" dev="dm-0" ino=8390105 ioctlcmd=0x1234
scontext=unconfined_u:unconfined_r:src_t:s0-s0:c0.c1023
tcontext=unconfined_u:object_r:tgt_t:s0 tclass=tcp_socket permissive=0
\end{lstlisting}
Field \texttt{ioctlcmd} contains first parameter of ioctl syscall that was
denied. This value can be used to construct an allowxperm rule to allow this
operation.

When used for troubleshooting this AVC denial, audit2allow produces the
following output:
\begin{lstlisting}
#============= src_t ==============

#!!!! This avc is allowed in the current policy
allow src_t tgt_t:tcp_socket ioctl;
\end{lstlisting}
which is not helpful. Administrator must know about extended permissions and
assume that the allow rule was overridden.

\subsection{Generating Extended permission AV rules in audit2allow}
% STATUS: 1
The audit2allow does have all the information to generate extended permission AV
rules. First of all, it should warn user, that the operation may have been
denied because of extended permission AV rules. In the preceding example, there
should be a warning message. Then there should be a way how to generate extended
permission AV rules from AVC messages, for example a command-line option.

% TODO: discussion about default behaviour
TODO

% ------------------------------------------------------------------------------
\section{Labeling Network Ports, Nodes and Interfaces}
SELinux policy supports labeling of TCP and UDP ports, network nodes
(represented by IP addresses and subnet masks), and network interfaces (e.g.
\texttt{eth0}).

\subsection{Network Ports}
% STATUS: 3
SELinux can enforce binding to system ports. For example, in Fedora 27, there
are several hundred \texttt{portcon} rules that label TCP and UDP ports.
Example:
\begin{lstlisting}
$ seinfo --portcon

Portcon: 615
   portcon tcp 1-511 system_u:object_r:reserved_port_t:s0
   portcon tcp 7 system_u:object_r:echo_port_t:s0
   portcon tcp 21 system_u:object_r:ftp_port_t:s0
   portcon tcp 22 system_u:object_r:ssh_port_t:s0
   portcon tcp 53 system_u:object_r:dns_port_t:s0
   portcon tcp 80 system_u:object_r:http_port_t:s0
   portcon udp 1-511 system_u:object_r:reserved_port_t:s0
   portcon udp 1 system_u:object_r:inetd_child_port_t:s0
   portcon udp 7 system_u:object_r:echo_port_t:s0
   portcon udp 53 system_u:object_r:dns_port_t:s0
   portcon udp 67 system_u:object_r:dhcpd_port_t:s0
   ...
\end{lstlisting}
Portcon rules can overlap, for example TCP port number 80 is labeled
\texttt{http\_port\_t} but also \texttt{reserved\_port\_t} because it is in range
1--511. Every port has either domain-specific label or one of the following
labels (based on range):

\begin{tabular}{l l}
    1--511 & \texttt{reserved\_port\_t} \\
    512--1023 & \texttt{hi\_reserved\_port\_t} \\
    1024--32767 & \texttt{unreserved\_port\_t} \\
    32768--61000 & \texttt{ephemeral\_port\_t} \\
    61001--65535 & \texttt{unreserved\_port\_t} \\
\end{tabular}

When a process tries to bind port and it is denied by policy, AVC message is
generated. For example:
\begin{lstlisting}
type=AVC msg=audit(1516026512.648:4191): avc:  denied  { name_bind } for
pid=6116 comm="test" src=43 scontext=unconfined_u:unconfined_r:my_app_t:s0
tcontext=system_u:object_r:reserved_port_t:s0
tclass=tcp_socket permissive=0
\end{lstlisting}

Proper way how to allow the process to bind on port number 43 would be to label
this port with a application-specific context. The audit2allow suggest adding
the following rule to the policy:
\begin{lstlisting}
allow my_app_t reserved_port_t:tcp_socket name_bind;
\end{lstlisting}
This rule would allow \texttt{my\_app\_t} access to all reserved ports which is
unneccessary and potentially unsecure.

Ports can be labeled using the \texttt{portcon} rules, but as of policy version
31, these rules are not valid in policy module, only in base policy. So
audit2allow would not be able to generate \texttt{portcon} rules directly.
Another way of labeling ports is via the \texttt{semanage port} command. The
audit2allow should suggest using the \texttt{semanage port} command when
appropriate.

\subsection{Network Nodes}
% STATUS: 1
SELinux is capable of labeling network nodes. For example, there can be rules
that allow process to communicate only on private LAN or even only on local
host. Attempts to violate these rules would then produce AVC denial messages
that contain IP address of the node.

% TODO: rewrite
Proper solution would be to modify label of certain subnet on the network. AVC
denial messages provides only the IP addresses. As IP addresses can change
often, labeling single network node would not be useful.

\subsection{Network Interfaces}
% STATUS: 0
% TODO: write or remove?
TODO

% ==============================================================================
\chapter{Implementation}
% STATUS: 2
From the list of possible improvements to audit2allow, extended permissions were
implemented.

% ------------------------------------------------------------------------------
\section{Extended permissions}
% STATUS: 3
Modules \texttt{audit}, \texttt{access}, \texttt{policygen}, \texttt{refpolicy}
were modified to support extended permissions. New command-line option
\texttt{-{}-xperms} was added to turn on generating of the extended permission
access vector rules.

\subsection{Parsing AVC Denial Messages}
% STATUS: 4
The \texttt{audit} module was extended to parse \texttt{ioctlcmd} field in AVC
denial messages. The \texttt{ioctlcmd} field is then converted to fit the
general concept of extended permissions and passed to the access vector set.

\subsection{Storing Extended Permissions in Access Vector Sets}
% STATUS: 3
Extended permissions are stored inside an access vector as a dictionary, where
the operation is the key. Example of extended permissions:
\begin{lstlisting}
{
    'ioctl': <refpolicy.XpermSet() object>,
    'other_command': <refpolicy.XpermSet() object>,
    'another_command': <refpolicy.XpermSet() object>,
}
\end{lstlisting}
The \texttt{AccessVectorSet} was modified to correctly merge two access vectors
with extended permissions attached.

\subsection{Representation of Extended Permission AV Rules}
% STATUS: 2
Extended permission access vector rules are represented in the
\texttt{refpolicy} module by the \texttt{AVExtRule} class. These rules are
created from access vectors using the \texttt{from\_av()} method. Method
\texttt{to\_string()} prints out the rule. Example of an extended permission AV
rule:
\begin{lstlisting}
allowxperm my_app_t my_socket_t : tcp_socket ioctl { 20 30 0x40 50-60 };
\end{lstlisting}

The extended permission set (in the previous listing \texttt{\{ 20 30 0x40 50-60
\}}) is represented by separate class \texttt{XpermSet}.

\subsection{Generating Extended Permission AV rules}
% STATUS: 3
Without extended permissions, every access vector can be converted into single
AV rule. With extended permissions attached to the access vector, to fully
convert access vector to policy rules, there needs to be one AV rule and
possibly several extended permission AV rules. For example, this access vector:
% TODO use different contexts and tcp_socket
\begin{lstlisting}
{
    source_context: 'unconfined_u:system_r:httpd_t:s0',
    target_context: 'system_u:object_r:samba_share_t:s0',
    object_class: 'file',
    permissions: [ 'getattr', 'ioctl', 'open' ]
    extended_permissions: {
        'ioctl': [ 1, 2, 3 ],
        'other_command': [ 40, 50, 60 ],
        'another_command': [ 700, 800, 900 ],
    }
}
\end{lstlisting}
would be converted into these policy rules\footnote{Note that as of policy
version 31, only the \texttt{ioctl} operation is supported, operations
\texttt{other\_command} and \texttt{another\_command} were added only as an
example.}:
\begin{lstlisting}
allow httpd_t samba_share_t:file { getattr ioctl open };
allowxperm httpd_t samba_share_t:file ioctl { 1 2 3 };
allowxperm httpd_t samba_share_t:file other_command { 40 50 60 };
allowxperm httpd_t samba_share_t:file another_command { 700 800 900 };
\end{lstlisting}

The \texttt{PolicyGenerator} was modified to generate extended permission AV
rules for every operation in access vector. New configuration method was added,
\texttt{set\_gen\_xperms()}, to specify whether the extended permission AV rules
should be generated.

% ==============================================================================
\chapter{Functional Testing}
% STATUS: 3
% TODO: write about tests, chosen coverage
The functionality of implemented features to audit2allow was tested by extending
existing unit tests and writing integration tests that are focused on operation
with SELinux and Linux Audit system.

% ------------------------------------------------------------------------------
\section{Unit Tests}
% STATUS: 1
% TODO: write more stuff

Unit tests were extended to ensure that the new functionality does not break
existing code. New test cases were added to test the new features.

\subsection{Testing audit Module}
% STATUS: 1
% TODO: write

In this module, audit message parser was modified to recognize new fields and to
convert the fields to extended permissions.

\subsection{Testing access Module}
% STATUS: 2
% TODO: write

In this module, classes \texttt{AccessVector} and \texttt{AccessVectorSet} were
extended. Tests are implemented in the \texttt{test\_access.py} module.

\subsubsection{Testing \texttt{AccessVector.\_\_init\_\_()}}
Tests are implemented in the \texttt{TestAccessVector} class.

\begin{description}
    \item [\texttt{test\_init()}] Test that
        \texttt{AccessVector.xperms} is a dictionary.
\end{description}

\subsubsection{Testing \texttt{AccessVector.merge()}}
Tests are implemented in the \texttt{TestAccessVector} class. Method inputs:
\begin{description}
    \item [\texttt{self.perms}, \texttt{av.perms}] Lists of permissions.
    \item [\texttt{self.xperms}, \texttt{av.xperms}] Dictionaries, keys are
        strings, values are \texttt{XpermSet} objects.
\end{description}

Test cases:
\begin{description}
    \item [\texttt{test\_merge\_noxperm()}] Test merging two AVs without
        extended permissions.
    \item [\texttt{test\_merge\_xperm1()}] Test merging AV that contains
        extended permissions with AV that does not.
    \item [\texttt{test\_merge\_xperm2()}] Test merging AV that does not contain
        extended permissions with AV that does.
    \item [\texttt{test\_merge\_xperm\_diff\_op()}] Test merging two AVs both
        containing extended permissions, but with different operations.
    \item [\texttt{test\_merge\_xperm\_same\_op()}] Test merging two AVs both
        containing extended permissions with the same operation.
\end{description}

\subsubsection{Testing \texttt{AccessVector.add\_av()}}
Tests are implemented in the \texttt{TestAccessVectorSet} class. Method inputs:
\begin{description}
    \item [\texttt{self.src}] Already added access vectors.
    \item [\texttt{av}] An \texttt{AccessVector} instance.
    \item [\texttt{audit\_msg}] Audit message to be attached to the access
        vector.
\end{description}

Test cases:
\begin{description}
    \item [\texttt{test\_add\_av\_first()}] Test adding first access vector to
        the access vector set.
    \item [\texttt{test\_add\_av\_second()}] Test adding second AV to the set
        with same source and target context and class.
    \item [\texttt{test\_add\_av\_with\_msg()}] Test adding audit message.
\end{description}

\subsubsection{Testing \texttt{AccessVector.add()}}
This method just creates an instance of \texttt{AccessVector} classed and passes
the AV to the \texttt{AccessVector.add\_av()} method.

Test cases:
\begin{description}
    \item [\texttt{test\_add()}] Test adding access vector to the set.
\end{description}

\subsection{Testing policygen Module}
% STATUS: 1
% TODO: write

In this module, \texttt{PolicyGenerator} was extended to generate extended
permission access vector modules.

\subsection{Testing refpolicy Module}
% STATUS: 1
% TODO: write

The \texttt{XpermSet} and \texttt{AVExtRule} classes were added to represent
extended permission access vector rules.

% ------------------------------------------------------------------------------
\section{Integration Tests}
% STATUS: 0
% TODO: write

TODO

\chapter{Conclusion}
% STATUS: 0
% Závěrečná kapitola obsahuje zhodnocení dosažených výsledků se zvlášť
% vyznačeným vlastním přínosem studenta. Povinně se zde objeví i zhodnocení z
% pohledu dalšího vývoje projektu, student uvede náměty vycházející ze
% zkušeností s řešeným projektem a uvede rovněž návaznosti na právě dokončené
% projekty (řešené v rámci ostatních bakalářských prací v daném roce nebo na
% projekty řešené na externích pracovištích). 

% TODO: write

% 1. Conclusions: concise statements about your main findings, related to your
%       aims/objectives/hypothesis.

% 2. Contributions to your field of research, stating/restating the significance
%       of what you have discovered. Can include limitations.
Support for extended permissions was added to audit2allow.

% 3. Future research:
%       where to go from here (can include where NOT to go, if your research
%       demonstrated that a particular approach or avenue was not useful).
Other improvements can be implemented.
